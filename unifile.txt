=====================================================================
Document 1: File name Verbosity.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile, Verbosity

- Description
package com.ingenifi.unifile

interface VerbosePrinting {
    fun verbosePrint(message: String)
    fun verbosePrint(message: String, withLevel: Int)
}

data class Verbosity(val verbose : Boolean, val level : Int) {
    fun increasedLevel(by : Int = 1): Int = level + by

    fun increasingBy(by: Int = 1): Verbosity = copy(level = level + by)

    companion object {
        val NONE: Verbosity = Verbosity(false, 0)
    }

}

data class VerbosePrinter(val verbose: Boolean, val level: Int) : VerbosePrinting {

    constructor(verbosity: Verbosity) : this(verbosity.verbose, verbosity.level)
    override fun verbosePrint(message: String): Unit = if (verbose) printMessage(message) else Unit
    override fun verbosePrint(message: String, withLevel: Int) = if (verbose) printMessage(message, withLevel = withLevel) else Unit
    private fun printMessage(message: String, withLevel: Int = level) = println(format(message, withLevel))
    private fun format(message: String, withLevel: Int = level): String = indentation(withLevel) + "o $message"
    private fun indentation(level: Int): String = " ".repeat(INDENT * level)

    companion object {
        const val INDENT = 2
    }
}


=====================================================================
Document 2: File name InputPaths.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.input, InputPaths

- Description
package com.ingenifi.unifile.input

class InputPaths(paths: List<String>) {
    val list: List<InputPath> = paths.map { InputPath(it) }

    fun allFiles() = list.flatMap { it.findFiles() }
}


=====================================================================
Document 3: File name InputPath.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.input, InputPath

- Description
package com.ingenifi.unifile.input

import java.io.File

class InputPath(private val pathName: String) {
    fun findFiles(): List<File> = when {
        pathName == "." -> File(".").walkTopDown().filter { it.isFile }.toList()
        File(pathName).isDirectory -> File(pathName).walkTopDown().filter { it.isFile }.toList()
        else -> listOf(File(pathName))
    }
}


=====================================================================
Document 4: File name UnsecuredHttpClient.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile, UnsecuredHttpClient

- Description
package com.ingenifi.unifile

import io.ktor.client.*
import io.ktor.client.engine.java.*
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager
import java.security.cert.X509Certificate

object UnsecuredHttpClient {

    fun create(): HttpClient {
        val sslContext = createInsecureSslContext()

        return HttpClient(Java) {
            engine {
                config {
                    sslContext(sslContext)
                    // Additional SSL parameters can be configured here if needed
                }
            }
        }
    }

    private fun createInsecureSslContext(): SSLContext {
        val trustAllCerts = arrayOf<TrustManager>(object : X509TrustManager {
            override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
            override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
            override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {}
        })

        return SSLContext.getInstance("TLS").apply {
            init(null, trustAllCerts, java.security.SecureRandom())
        }
    }
}



=====================================================================
Document 5: File name FileOutputPath.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.output, FileOutputPath

- Description
package com.ingenifi.unifile.output

import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

data class FileOutputPath(var path: String?) : OutputPath {
    init {
        if (path.isNullOrEmpty()) {
            path = generatePathName()
        }
    }

    override fun write(text: String) {
        File(path!!).apply {
            parentFile?.mkdirs()  // Ensure the directory exists
            // Change to appendText to add to the file rather than overwrite it
            appendText(text)
        }
    }

    private fun generatePathName(): String {
        return "unifile-${LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MMM-dd-HH:mm:ss"))}.txt"
    }
}


=====================================================================
Document 6: File name OutputPath.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.output, OutputPath

- Description
package com.ingenifi.unifile.output

sealed interface OutputPath {

    companion object {
        fun from(pathName: String?): OutputPath = if (pathName == null) ConsoleOutputPath else FileOutputPath(pathName)
    }

    fun write(text: String)

    object ConsoleOutputPath : OutputPath {
        override fun write(text: String) {
            println(text)
        }
    }
}


=====================================================================
Document 7: File name UniFile.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile, UniFile

- Description
package com.ingenifi.unifile

import com.ingenifi.unifile.formatter.DocumentFormatterFactory
import com.ingenifi.unifile.formatter.KeywordExtractor
import com.ingenifi.unifile.input.InputPaths
import com.ingenifi.unifile.output.OutputPath

// TODO:  More formal testing

data class UniFile(val input: InputPaths, val properties: Map<String, String>, val verbosity: Verbosity) : VerbosePrinting by VerbosePrinter(verbosity) {
    private val documentFormatterFactory = DocumentFormatterFactory(properties = properties, keywordExtractor = KeywordExtractor(), client = UnsecuredHttpClient.create(), verbosity = verbosity.increasingBy(by = 2))
    private var documentNumber = 1

    fun combineFiles(output: OutputPath) {
        verbosePrint("Processing files")
        val withLevel = verbosity.increasedLevel()
        val documents = input.allFiles().joinToString("\n") {
            verbosePrint("Processing file #${documentNumber}: $it", withLevel = withLevel)
            val documentFormatter = documentFormatterFactory.create(it)
            documentFormatter.format(documentNumber++)
        }
        output.write(documents)
    }
}







=====================================================================
Document 8: File name UniFileCli.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile, UniFileCli

- Description
package com.ingenifi.unifile

import com.ingenifi.unifile.input.InputPaths
import com.ingenifi.unifile.output.FileOutputPath
import com.ingenifi.unifile.output.OutputPath
import org.slf4j.LoggerFactory
import picocli.CommandLine
import java.io.File
import java.util.*
import java.util.concurrent.Callable

@CommandLine.Command(
    name = "unifile", mixinStandardHelpOptions = true, description = ["Utility to process and combine files."]
)
class UniFileCli : Callable<Int> {

    private val logger = LoggerFactory.getLogger(UniFileCli::class.java)

    @CommandLine.Option(names = ["-i", "--input"], description = ["Input files or directories"])
    private var inputPaths: Array<String> = arrayOf()

    @CommandLine.Option(names = ["-o", "--output"], description = ["Output file path"])
    private var outputPath: String? = null

    @CommandLine.Option(names = ["-p", "--properties"], description = ["Properties file path"])
    private var propertiesFilePath: String? = null

    @CommandLine.Option(names = ["-v", "--verbose"], description = ["Enable verbose output"])
    private var verbose: Boolean = false


    private fun loadProperties(): Map<String, String> {
        val properties = Properties()
        val propertiesMap = mutableMapOf<String, String>()
        val propertiesFile = File(propertiesFilePath ?: System.getProperty("user.home") + File.separator + "unifile.properties")
        if (propertiesFile.exists()) {
            properties.load(propertiesFile.inputStream())
            properties.forEach { (key, value) ->
                propertiesMap[key.toString()] = value.toString()
            }
        } else {
            logger.warn("Properties file not found: ${propertiesFile.path}")
        }
        return propertiesMap
    }

    override fun call(): Int {
        val verbosity = Verbosity(verbose = verbose, level = 0)
        val printer = VerbosePrinter(verbosity)
        if (inputPaths.isEmpty()) {
            CommandLine.usage(this, System.out)
            return 1
        }
        return try {
            val output = OutputPath.from(pathName = outputPath)
            val input = InputPaths(paths = inputPaths.toList())
            val uniFile = UniFile(input = input, properties = loadProperties(), verbosity = verbosity)
            uniFile.combineFiles(output)
            if (output is FileOutputPath) printer.verbosePrint("Combined file created: ${output.path}") else printer.verbosePrint("Completed with output written to console")
            0
        } catch (e: Exception) {
            logger.error("Failed to process files: {}", e.message, e)
            1
        }
    }
}


=====================================================================
Document 9: File name Main.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile, Main

- Description
package com.ingenifi.unifile

import picocli.CommandLine

fun main(args: Array<String>) {
    System.setProperty("java.util.logging.config.file", "path/to/logging.properties")
    System.exit(CommandLine(UniFileCli()).execute(*args))
}


=====================================================================
Document 10: File name PlainTextSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.plaintext, PlainTextSource

- Description
package com.ingenifi.unifile.formatter.plaintext

import com.ingenifi.unifile.formatter.Source
import java.io.File

class PlainTextSource(private val file: File): Source {
    override fun description(): String = file.readText()
    override fun title(): String = file.name
}


=====================================================================
Document 11: File name PlainTextFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.plaintext, PlainTextFormatter

- Description
package com.ingenifi.unifile.formatter.plaintext

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class PlainTextFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(PlainTextSource(file), keywordExtractor)
    override fun format(number: Int): String = delegate.format(number, templatePath = "plain-document.tmpl", replacements = mapOf<String, String>("filename" to file.name))
    override fun lastNumber(): Int = delegate.lastNumber()
}


=====================================================================
Document 12: File name DocumentFormatterFactory.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter, DocumentFormatterFactory

- Description
package com.ingenifi.unifile.formatter

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.confluence.ConfluencePagesFormatter
import com.ingenifi.unifile.formatter.excel.ExcelFormatter
import com.ingenifi.unifile.formatter.jira.JiraFormatter
import com.ingenifi.unifile.formatter.json.JsonFormatter
import com.ingenifi.unifile.formatter.kotlin.KotlinFormatter
import com.ingenifi.unifile.formatter.pdf.PdfFormatter
import com.ingenifi.unifile.formatter.powerpoint.PowerPointFormatter
import com.ingenifi.unifile.formatter.word.WordFormatter
import io.ktor.client.*
import java.io.File

data class DocumentFormatterFactory(val properties: Map<String, String>, val keywordExtractor: KeywordExtractor, val client: HttpClient, val verbosity: Verbosity) :
    VerbosePrinting by VerbosePrinter(verbosity) {
    fun create(file: File): DocumentFormatter {
        return when (file.extension.lowercase()) {
            "confluence" -> ConfluencePagesFormatter(file = file, keywordExtractor = keywordExtractor, properties = properties, client = client, verbosity = verbosity)
            "doc" -> WordFormatter(file = file, keywordExtractor = keywordExtractor)
            "docx" -> WordFormatter(file = file, keywordExtractor = keywordExtractor)
            "jira" -> JiraFormatter(file = file, keywordExtractor = keywordExtractor, properties = properties, client = client, verbosity = verbosity)
            "json" -> JsonFormatter(file = file, keywordExtractor = keywordExtractor)
            "kt" -> KotlinFormatter(file = file, keywordExtractor = keywordExtractor)
            "pdf" -> PdfFormatter(file = file, keywordExtractor = keywordExtractor)
            "ppt" -> PowerPointFormatter(file = file, keywordExtractor = keywordExtractor)
            "pptx" -> PowerPointFormatter(file = file, keywordExtractor = keywordExtractor)
            "txt" -> KotlinFormatter(file = file, keywordExtractor = keywordExtractor)
            "xls" -> ExcelFormatter(file = file, keywordExtractor = keywordExtractor)
            "xlsx" -> ExcelFormatter(file = file, keywordExtractor = keywordExtractor)

            else -> throw IllegalArgumentException("Unknown formatter for extension ${file.extension.lowercase()}: given ${file.name}")
        }
    }
}


=====================================================================
Document 13: File name Source.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter, Source

- Description
package com.ingenifi.unifile.formatter

interface Source {
    fun description() : String
    fun title() : String

}




=====================================================================
Document 14: File name ExcelFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.excel, ExcelFormatter

- Description
package com.ingenifi.unifile.formatter.excel

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class ExcelFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(ExcelSource(file), keywordExtractor)
    override fun format(number: Int): String = delegate.format(number, templatePath = "excel-document.tmpl", replacements = mapOf<String, String>("filename" to file.name))
    override fun lastNumber(): Int = delegate.lastNumber()
}




=====================================================================
Document 15: File name ExcelConverter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.excel, ExcelConverter

- Description
package com.ingenifi.unifile.formatter.excel

import org.apache.poi.ss.usermodel.CellType
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import java.io.File
import java.io.FileInputStream
import java.io.StringWriter

class ExcelConverter {

    fun convert(excelFile: File): String {
        return convertToCsv(excelFile)
    }

    private fun convertToCsv(excelFile: File): String {
        FileInputStream(excelFile).use { fis ->
            val workbook = XSSFWorkbook(fis)
            val sheet = workbook.getSheetAt(0) // Assuming the first sheet
            val stringWriter = StringWriter()

            sheet.forEach { row ->
                val rowValues = row.map { cell ->
                    when (cell.cellType) {
                        CellType.STRING -> cell.stringCellValue
                        CellType.NUMERIC -> cell.numericCellValue.toString()
                        CellType.BOOLEAN -> cell.booleanCellValue.toString()
                        else -> ""
                    }.replace("\"", "\"\"") // Escape double quotes
                }

                // Skip rows where all cells are empty
                if (rowValues.any { it.isNotEmpty() }) {
                    val csvRow = rowValues.joinToString(",") { "\"$it\"" } // Quote each field
                    stringWriter.write("$csvRow\n")
                }
            }

            workbook.close()
            return stringWriter.toString()
        }
    }
}



=====================================================================
Document 16: File name ExcelSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.excel, ExcelSource

- Description
package com.ingenifi.unifile.formatter.excel

import com.ingenifi.unifile.formatter.Source
import java.io.File

data class ExcelSource(val file: File) : Source {
    override fun description(): String = file.toText()
    override fun title(): String = file.name
    private fun File.toText(): String = ExcelConverter().convert(this)

}


=====================================================================
Document 17: File name PdfConverter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.pdf, PdfConverter

- Description
package com.ingenifi.unifile.formatter.pdf

import com.itextpdf.kernel.pdf.PdfDocument
import com.itextpdf.kernel.pdf.PdfReader
import com.itextpdf.kernel.pdf.canvas.parser.PdfTextExtractor
import java.io.File

class PdfConverter {

    fun convert(pdf: File): String {
        val reader = PdfReader(pdf.absolutePath)
        val pdfDoc = PdfDocument(reader)
        val stringBuilder = StringBuilder()

        for (i in 1..pdfDoc.numberOfPages) {
            val page = pdfDoc.getPage(i)
            stringBuilder.append(PdfTextExtractor.getTextFromPage(page)).append("\n")
        }

        pdfDoc.close()
        return stringBuilder.toString()
    }
}



=====================================================================
Document 18: File name PdfFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.pdf, PdfFormatter

- Description
package com.ingenifi.unifile.formatter.pdf

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class PdfFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(PdfSource(file), keywordExtractor)
    override fun format(number: Int): String = delegate.format(number, templatePath = "pdf-document.tmpl", replacements = mapOf<String, String>("filename" to file.name))
    override fun lastNumber(): Int = delegate.lastNumber()
}




=====================================================================
Document 19: File name PdfSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.pdf, PdfSource

- Description
package com.ingenifi.unifile.formatter.pdf

import com.ingenifi.unifile.formatter.Source
import java.io.File

data class PdfSource(val file: File) : Source {
    override fun description(): String = file.toText()
    override fun title(): String = file.name
    private fun File.toText(): String = PdfConverter().convert(this)

}


=====================================================================
Document 20: File name HtmlConverter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.html, HtmlConverter

- Description
package com.ingenifi.unifile.formatter.html

import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.io.PrintWriter

class HtmlConverter {
    fun convert(htmlContent: String): String? {
        try {
            val processBuilder = ProcessBuilder("pandoc", "-f", "html", "-t", "plain")
            processBuilder.redirectErrorStream(true)
            val process = processBuilder.start()
            val writer = PrintWriter(OutputStreamWriter(process.outputStream))
            writer.write(htmlContent)
            writer.close()
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            val output = StringBuilder()
            var line: String?

            while (reader.readLine().also { line = it } != null) {
                output.append(line).append("\n")
            }
            return if (process.waitFor() == 0) output.toString() else  null
        } catch (e: Exception) {
            // Handle any exceptions that may occur
            e.printStackTrace()
            return null
        }
    }
}



=====================================================================
Document 21: File name KotlinSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.kotlin, KotlinSource

- Description
package com.ingenifi.unifile.formatter.kotlin

import com.ingenifi.unifile.formatter.Source
import java.io.File

class KotlinSource(private val file: File): Source {
    override fun description(): String = file.readText()
    override fun title(): String = file.name
}


=====================================================================
Document 22: File name KotlinFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.kotlin, KotlinFormatter

- Description
package com.ingenifi.unifile.formatter.kotlin

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class KotlinFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(KotlinSource(file), keywordExtractor)
    override fun format(number: Int): String {
        val keywords = mutableListOf<String>()
        keywords.add("kotlin")
        keywords.add(getPackageInformation(file))
        keywords.add(file.name.substringBeforeLast("."))
        return delegate.format(number, templatePath = "kotlin-document.tmpl", replacements = mapOf<String, String>("filename" to file.name), additionalKeywords = keywords)
    }

    private fun getPackageInformation(file: File): String {
        val packageLine = file.readLines().first { it.startsWith("package") }
        return packageLine.substringAfter("package").trim()
    }

    override fun lastNumber(): Int = delegate.lastNumber()
}


=====================================================================
Document 23: File name XmlSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.xml, XmlSource

- Description
package com.ingenifi.unifile.formatter.xml

import com.ingenifi.unifile.formatter.Source
import org.w3c.dom.Element
import org.w3c.dom.Node
import java.io.File
import javax.xml.parsers.DocumentBuilderFactory

class XmlSource(private val file : File) : Source {
    override fun description(): String {
        val documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        val document = documentBuilder.parse(file)
        val root = document.documentElement
        return buildString { appendXmlContent(root, 0, this) }
    }

    private fun appendXmlContent(node: Node, depth: Int, builder: StringBuilder) {
        val indent = "  ".repeat(depth)

        if (node.nodeType == Node.ELEMENT_NODE && !isNodeEmpty(node)) {
            val attributes = getNodeAttributes(node)
            builder.appendLine("$indent${node.nodeName}${attributes}:")
            val childNodes = node.childNodes
            for (i in 0 until childNodes.length) {
                appendXmlContent(childNodes.item(i), depth + 1, builder)
            }
        } else if (node.nodeType == Node.TEXT_NODE) {
            val textContent = node.textContent.trim()
            if (textContent.isNotEmpty()) {
                builder.appendLine("$indent$textContent")
            }
        }
    }

    private fun getNodeAttributes(node: Node): String {
        if (node.nodeType != Node.ELEMENT_NODE) return ""

        val element = node as Element
        val attributes = element.attributes
        return (0 until attributes.length).asSequence().map { attributes.item(it) }.filter { it.nodeValue.trim().isNotEmpty() }
            .joinToString(separator = ", ", prefix = " [", postfix = "]") { "${it.nodeName}=${it.nodeValue}" }
    }

    private fun isNodeEmpty(node: Node): Boolean {
        if (node.nodeType == Node.ELEMENT_NODE) {
            val hasNonEmptyText = node.textContent.trim().isNotEmpty()
            val hasChildren = (0 until node.childNodes.length).any {
                !isNodeEmpty(node.childNodes.item(it))
            }
            return !hasNonEmptyText && !hasChildren
        }
        return false
    }

    override fun title(): String = file.name

}


=====================================================================
Document 24: File name XmlFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.xml, XmlFormatter

- Description
package com.ingenifi.unifile.formatter.xml

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import org.w3c.dom.Element
import org.w3c.dom.Node
import java.io.File
import javax.xml.parsers.DocumentBuilderFactory

data class XmlFormatter(private val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(XmlSource(file), keywordExtractor)

    override fun format(number: Int): String = delegate.format(number, "xml-document.tmpl")

    override fun lastNumber(): Int = delegate.lastNumber()
    private fun getBodyFromXml(): String {
        val documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder()
        val document = documentBuilder.parse(file)
        val root = document.documentElement
        return buildString {
            appendXmlContent(root, 0, this)
        }
    }

    private fun appendXmlContent(node: Node, depth: Int, builder: StringBuilder) {
        val indent = "  ".repeat(depth)

        if (node.nodeType == Node.ELEMENT_NODE && !isNodeEmpty(node)) {
            val attributes = getNodeAttributes(node)
            builder.appendLine("$indent${node.nodeName}${attributes}:")
            val childNodes = node.childNodes
            for (i in 0 until childNodes.length) {
                appendXmlContent(childNodes.item(i), depth + 1, builder)
            }
        } else if (node.nodeType == Node.TEXT_NODE) {
            val textContent = node.textContent.trim()
            if (textContent.isNotEmpty()) {
                builder.appendLine("$indent$textContent")
            }
        }
    }

    private fun getNodeAttributes(node: Node): String {
        if (node.nodeType != Node.ELEMENT_NODE) return ""

        val element = node as Element
        val attributes = element.attributes
        return (0 until attributes.length).asSequence().map { attributes.item(it) }.filter { it.nodeValue.trim().isNotEmpty() }
            .joinToString(separator = ", ", prefix = " [", postfix = "]") { "${it.nodeName}=${it.nodeValue}" }
    }

    private fun isNodeEmpty(node: Node): Boolean {
        if (node.nodeType == Node.ELEMENT_NODE) {
            val hasNonEmptyText = node.textContent.trim().isNotEmpty()
            val hasChildren = (0 until node.childNodes.length).any {
                !isNodeEmpty(node.childNodes.item(it))
            }
            return !hasNonEmptyText && !hasChildren
        }
        return false
    }
}


=====================================================================
Document 25: File name DocumentFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter, DocumentFormatter

- Description
package com.ingenifi.unifile.formatter

interface DocumentFormatter {
    fun format(number: Int): String
    fun lastNumber(): Int
}




=====================================================================
Document 26: File name JsonSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.json, JsonSource

- Description
package com.ingenifi.unifile.formatter.json

import com.ingenifi.unifile.formatter.Source
import java.io.File

data class JsonSource(val file : File) : Source {
    override fun description(): String = JsonConverter().convert(file.readText())

    override fun title(): String = file.name

}


=====================================================================
Document 27: File name JsonFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.json, JsonFormatter

- Description
package com.ingenifi.unifile.formatter.json

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class JsonFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(JsonSource(file), keywordExtractor)
    override fun format(number: Int): String = delegate.format(number,  templatePath = "json-document.tmpl", replacements = mapOf<String, String>( "filename" to file.name))
    override fun lastNumber(): Int = delegate.lastNumber()
}




=====================================================================
Document 28: File name JsonConverter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.json, JsonConverter

- Description
package com.ingenifi.unifile.formatter.json

import kotlinx.serialization.json.*

class JsonConverter {

    fun convert(json: String): String {
        val jsonElement = Json.parseToJsonElement(json)
        return buildString { parseJsonElement(jsonElement, 0, this) }
    }

    private fun parseJsonElement(element: JsonElement, indent: Int, builder: StringBuilder) {
        when {
            element is JsonObject -> {
                element.forEach { (key, value) ->
                    if (!value.isNull() && !(value is JsonPrimitive && value.content.isBlank())) {
                        builder.append("  ".repeat(indent)).append(key).append(":\n")
                        parseJsonElement(value, indent + 1, builder)
                    }
                }
            }
            element is JsonArray -> {
                element.forEach { arrayElement ->
                    if (!arrayElement.isNull() && !(arrayElement is JsonPrimitive && arrayElement.content.isBlank())) {
                        parseJsonElement(arrayElement, indent, builder)
                    }
                }
            }
            element is JsonPrimitive && !element.content.isBlank() -> {
                builder.append("  ".repeat(indent)).append(element.content).append("\n")
            }
            // JsonNull and blank JsonPrimitives are ignored
        }
    }

    private fun JsonElement.isNull(): Boolean = this is JsonNull
}



=====================================================================
Document 29: File name EpicFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.jira, EpicFormatter

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor

data class EpicFormatter(private val epic: Epic, val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) : DocumentFormatter, VerbosePrinting by VerbosePrinter(verbosity) {

    private val delegate = Delegate(EpicSource(epic), keywordExtractor)

    private var lastNumber = 0

    override fun format(number: Int): String {
        verbosePrint("Processing epic ${epic.key}: '${epic.title}' with ${epic.children.size} children")
        val childVerbosity = verbosity.increasingBy(1)
        val children = epic.children.mapIndexed { index, issue ->
            when (issue) {
                is Story -> EpicStoryFormatter(story = issue, epic, childNumber = index + 1, keywordExtractor, verbosity = childVerbosity).format(number)
                is Spike -> EpicSpikeFormatter(spike = issue, epic, childNumber = index + 1, keywordExtractor, verbosity = childVerbosity).format(number)
                else -> ""
            }
        }.joinToString("\n")
        val keywords = mutableListOf<String>()
        keywords.add("parent")
        keywords.add("epic")
        keywords.add(epic.key)
        keywords.add(epic.title)
        return delegate.format(
            number,
            templatePath = "epic-document.tmpl",
            replacements = mapOf<String, String>("key" to epic.key, "title" to epic.title, "introduction" to epic.introduction, "children" to children),
            additionalKeywords = keywords
        )
    }

    override fun lastNumber(): Int {
        TODO("Not yet implemented")
    }
}


=====================================================================
Document 30: File name StoryFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.jira, StoryFormatter

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor

data class StoryFormatter(private val story: Story, val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) : DocumentFormatter, VerbosePrinting by VerbosePrinter(verbosity) {

    private val delegate = Delegate(StorySource(story), keywordExtractor)

    private var lastNumber = 0

    override fun format(number: Int): String {
        verbosePrint("Processing story ${story.key}: '${story.title}'")
        lastNumber = number
        val keywords = mutableListOf<String>()
        keywords.add("story")
        keywords.add(story.key)
        return delegate.format(number, templatePath = "story-document.tmpl", replacements = mapOf<String, String>("key" to story.key, "title" to story.title), additionalKeywords = keywords)
    }

    override fun lastNumber(): Int = lastNumber + 1
}


=====================================================================
Document 31: File name EpicSpikeFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.jira, EpicSpikeFormatter

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor

data class EpicSpikeFormatter(private val spike: Spike, private val epic: Epic, private val childNumber: Int, val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) :
    DocumentFormatter, VerbosePrinting by VerbosePrinter(verbosity) {

    private val delegate = Delegate(SpikeSource(spike), keywordExtractor)

    private var lastNumber = 0
    override fun format(number: Int): String {
        verbosePrint("Processing child story ${spike.key}: '${spike.title}'")
        lastNumber = number
        val keywords = mutableListOf<String>()
        keywords.add("child")
        keywords.add("spike")
        keywords.add(spike.key)
        keywords.add(epic.title)
        return delegate.format(
            number, templatePath = "epic-spike-document.tmpl", replacements = mapOf<String, String>(
                "epicKey" to epic.key, "epicTitle" to epic.title, "key" to spike.key, "title" to spike.title, "epicNumber" to number.toString(), "number" to childNumber.toString()
            ), additionalKeywords = keywords
        )

    }

    override fun lastNumber(): Int = lastNumber + 1
}


=====================================================================
Document 32: File name StorySource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.jira, StorySource

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.formatter.Source

data class StorySource(val story: Story) : Source {
    override fun description(): String = story.description

    override fun title(): String = story.title
}


=====================================================================
Document 33: File name EpicSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.jira, EpicSource

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.formatter.Source

data class EpicSource(val epic: Epic) : Source {
    override fun description(): String = epic.description

    override fun title(): String = epic.title
}


=====================================================================
Document 34: File name Issues.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.jira, Issues

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity

data class IssueFactory(private val api: JiraApi, val verbosity: Verbosity) : VerbosePrinting by VerbosePrinter(verbosity) {

    fun create(key: String): Issue {
        verbosePrint("Retrieving issue $key from Jira")
        val data = api.getIssue(key)
        return when (type(data)) {
            "epic" -> Epic(key = key, title = data?.get(EPIC_TITLE) as String, introduction = data[EPIC_INTRO] as String, description = data[DESCRIPTION] as String, children = children(key))
            "story" -> Story(key, title = data?.get(TITLE) as String, description = data[DESCRIPTION] as String)
            "spike" -> Spike(key, title = data?.get(TITLE) as String, description = data[DESCRIPTION] as String)
            else -> throw IllegalArgumentException("no can handle")
        }
    }

    private fun children(key: String): MutableList<Issue> = api.getChildren(key).map { create(it) }.toMutableList()

    private fun type(data: Map<String, Any>?): String {

        val issueTypeMap = data?.get(ISSUE_TYPE) as Map<String, Any>
        val type = issueTypeMap["name"] as String
        return type.lowercase()
    }

    companion object {
        val ISSUE_TYPE = "issuetype"
        val EPIC_TITLE = "customfield_10304"
        val EPIC_INTRO = "summary"
        val DESCRIPTION = "description"
        val TITLE = "summary"
    }

}

sealed interface Issue {
    val key: String
}

data class Epic(override val key: String, val title: String, val introduction: String, val description: String, val children: MutableList<Issue> = mutableListOf()) : Issue
data class Story(override val key: String, val title: String, val description: String) : Issue
data class Spike(override val key: String, val title: String, val description: String) : Issue



=====================================================================
Document 35: File name JiraFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.jira, JiraFormatter

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import io.ktor.client.*
import java.io.File

data class JiraFormatter(val properties : Map<String, String>, val file: File, val client: HttpClient, val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) : DocumentFormatter,
    VerbosePrinting by VerbosePrinter(verbosity) {
    private val jiraBaseUrl = properties["jiraBaseUrl"] ?: throw IllegalArgumentException("Jira base URL not specified in properties")
    private val apiToken = properties["apiToken"] ?: throw IllegalArgumentException("Jir API Token not specified in properties")
    private val api = JiraApi(client = client, jiraBaseUrl = jiraBaseUrl, apiToken = apiToken)

    private var lastNumber = 0
    private val factory = IssueFactory(api = api, verbosity = verbosity.increasingBy(1))
    private val issueVerbosity = factory.verbosity.increasingBy(1)
    private val documents = mutableListOf<String>()
    private val keys = file.readLines()

    override fun format(number: Int): String {
        for (key in keys) {
            val issue = factory.create(key)
            documents.add(formatIssue(issue))
        }
        return documents.joinToString("\n")
    }

    private fun formatIssue(issue: Issue): String = when (issue) {
        is Epic -> EpicFormatter(epic = issue, keywordExtractor = keywordExtractor, verbosity = issueVerbosity).format(lastNumber++)
        is Story -> StoryFormatter(story = issue, keywordExtractor = keywordExtractor, verbosity = issueVerbosity).format(lastNumber++)
        is Spike -> SpikeFormatter(spike = issue, keywordExtractor = keywordExtractor, verbosity = issueVerbosity).format(lastNumber++)
    }


    override fun lastNumber(): Int = lastNumber
}


=====================================================================
Document 36: File name JiraApi.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.jira, JiraApi

- Description
package com.ingenifi.unifile.formatter.jira

import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import java.net.URLEncoder
import java.nio.charset.StandardCharsets

class JiraApi(private val client: HttpClient, private val jiraBaseUrl: String, private val apiToken: String) {
    private val mapper = jacksonObjectMapper().apply {
        enable(SerializationFeature.INDENT_OUTPUT)
    }


    fun getChildren(epicKey: String): List<String> = runBlocking {
        val authHeader = "Bearer $apiToken"
        val jqlQuery = URLEncoder.encode("\"Epic Link\" = $epicKey", StandardCharsets.UTF_8.toString())
        val response = client.get("$jiraBaseUrl/rest/api/2/search?jql=$jqlQuery") {
            header("Authorization", authHeader)
            header("Accept", "application/json")
        }.bodyAsText()

        val jsonElement = Json.parseToJsonElement(response)
        val issues = jsonElement.jsonObject["issues"]?.jsonArray ?: return@runBlocking emptyList()

        issues.mapNotNull { issue ->
            issue.jsonObject["key"]?.jsonPrimitive?.content
        }
    }

    fun getIssue(key: String): Map<String, Any>? = runBlocking {
        val authHeader = "Bearer $apiToken"
        val urlString = "$jiraBaseUrl/rest/api/2/issue/$key"
        client.get(urlString) {
            header("Authorization", authHeader)
            header("Accept", "application/json")
        }.body<HttpResponse>().let {
            val epicData = mapper.readValue<Map<String, Any>>(it.bodyAsText())
            epicData["fields"] as? Map<String, Any>
        }
    }
}



=====================================================================
Document 37: File name SpikeSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.jira, SpikeSource

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.formatter.Source

data class SpikeSource(val spike: Spike) : Source {
    override fun description(): String = spike.description

    override fun title(): String = spike.title
}


=====================================================================
Document 38: File name SpikeFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.jira, SpikeFormatter

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor

data class SpikeFormatter(private val spike: Spike, val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) : DocumentFormatter, VerbosePrinting by VerbosePrinter(verbosity) {

    private val delegate = Delegate(SpikeSource(spike), keywordExtractor)

    private var lastNumber = 0

    override fun format(number: Int): String {
        verbosePrint("Processing spike ${spike.key}: '${spike.title}'")

        lastNumber = number
        val keywords = mutableListOf<String>()
        keywords.add("spike")
        keywords.add(spike.key)
        return delegate.format(number, templatePath = "story-document.tmpl", replacements = mapOf<String, String>("key" to spike.key, "title" to spike.title), additionalKeywords = keywords)
    }

    override fun lastNumber(): Int = lastNumber + 1
}


=====================================================================
Document 39: File name EpicStoryFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.jira, EpicStoryFormatter

- Description
package com.ingenifi.unifile.formatter.jira

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor

data class EpicStoryFormatter(private val story: Story, private val epic: Epic, private val childNumber: Int, val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) :
    DocumentFormatter, VerbosePrinting by VerbosePrinter(verbosity) {

    private val delegate = Delegate(StorySource(story), keywordExtractor)

    private var lastNumber = 0
    override fun format(number: Int): String {
        verbosePrint("Processing child story ${story.key}: '${story.title}'")
        lastNumber = number
        val keywords = mutableListOf<String>()
        keywords.add("child")
        keywords.add("story")
        keywords.add(story.key)
        keywords.add(epic.title)
        return delegate.format(
            number, templatePath = "epic-story-document.tmpl", replacements = mapOf<String, String>(
                "epicKey" to epic.key, "epicTitle" to epic.title, "key" to story.key, "title" to story.title, "epicNumber" to number.toString(), "number" to childNumber.toString()
            ), additionalKeywords = keywords
        )

    }

    override fun lastNumber(): Int = lastNumber + 1
}


=====================================================================
Document 40: File name PowerPointConverter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.powerpoint, PowerPointConverter

- Description
package com.ingenifi.unifile.formatter.powerpoint

import com.ingenifi.unifile.formatter.pdf.PdfConverter
import java.io.File

class PowerPointConverter {

    fun convert(powerPointFile: File): String {
        val pdf = convertToPdf(powerPointFile)
        return PdfConverter().convert(pdf)
    }

    private fun convertToPdf(pptxFile: File): File {
        val pdfFileName = pptxFile.absolutePath.replaceAfterLast('.', "pdf")
        val processBuilder = ProcessBuilder("libreoffice", "--headless", "--convert-to", "pdf", pptxFile.absolutePath)
        val process = processBuilder.start()
        val exitCode = process.waitFor()

        if (exitCode != 0) {
            throw RuntimeException("LibreOffice conversion failed with exit code $exitCode")
        }

        return File(pdfFileName)
    }
}


=====================================================================
Document 41: File name PowerPointFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.powerpoint, PowerPointFormatter

- Description
package com.ingenifi.unifile.formatter.powerpoint

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class PowerPointFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(PowerPointSource(file), keywordExtractor)
    override fun format(number: Int): String = delegate.format(number, templatePath = "powerpoint-document.tmpl", replacements = mapOf<String, String>("filename" to file.name))
    override fun lastNumber(): Int = delegate.lastNumber()
}




=====================================================================
Document 42: File name PowerPointSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.powerpoint, PowerPointSource

- Description
package com.ingenifi.unifile.formatter.powerpoint

import com.ingenifi.unifile.formatter.Source
import java.io.File

data class PowerPointSource(val file: File) : Source {
    override fun description(): String = file.toText()
    override fun title(): String = file.name
    private fun File.toText(): String = PowerPointConverter().convert(this)

}


=====================================================================
Document 43: File name ConfluenceApi.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.confluence, ConfluenceApi

- Description
package com.ingenifi.unifile.formatter.confluence

import com.ingenifi.unifile.formatter.html.HtmlConverter
import com.jayway.jsonpath.JsonPath
import io.ktor.client.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import org.jsoup.Jsoup
import org.slf4j.LoggerFactory
import java.util.*

class ConfluenceApi(
    private val client: HttpClient, user: String, password: String, private val apiUrlPattern: String = "https://confluence.kohls.com:8443/rest/api/content/%s?expand=body.view"
) {
    private val encodedCredentials = Base64.getEncoder().encodeToString("$user:$password".toByteArray())

    private val logger by lazy { LoggerFactory.getLogger(ConfluenceApi::class.java) }

    suspend fun fetchPageId(url: String): String? {
        val doc = Jsoup.parse(httpGet(url))
        val pageIdMetaTag = doc.select("meta[name=ajs-page-id]").firstOrNull()
        return pageIdMetaTag?.attr("content")
    }

    suspend fun fetch(pageId: String, vararg options: FetchOption) = fetch(pageId, options.toList())
    suspend fun fetch(pageId: String, options: List<FetchOption>): FetchResult {
        val apiUrl = apiUrlPattern.format(pageId)
        val response = httpGet(apiUrl)
        val resultMap = mutableMapOf<String, Any>()
        options.forEach { option ->
            val result = JsonPath.read<Any?>(response, option.path)
            resultMap[option.key] = if (option.interpretAsHtml) {
                htmlToPlainText(result.toString())
            } else {
                result
            }
        }
        return FetchResult(resultMap)
    }

    private suspend fun httpGet(request: String): String = client.get(request) {
        header("Authorization", "Basic $encodedCredentials")
    }.bodyAsText()

    companion object {
        fun htmlToPlainText(html: String): String = HtmlConverter().convert(html)!!
    }
}


=====================================================================
Document 44: File name FetchOption.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.confluence, FetchOption

- Description
package com.ingenifi.unifile.formatter.confluence

data class FetchOption(
    val key: String, val path: String, val interpretAsHtml: Boolean = false
)


=====================================================================
Document 45: File name ConfluencePageFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.confluence, ConfluencePageFormatter

- Description
package com.ingenifi.unifile.formatter.confluence

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor

data class ConfluencePageFormatter(private val link : ConfluenceLink, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(link, keywordExtractor)
    override fun format(number: Int): String  = delegate.format(number,  "confluence-document.tmpl",  extractPercentage = 0.1)
    override fun lastNumber(): Int = delegate.lastNumber()
}


=====================================================================
Document 46: File name ConfluenceLink.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.confluence, ConfluenceLink

- Description
package com.ingenifi.unifile.formatter.confluence

import com.ingenifi.unifile.formatter.Source

data class ConfluenceLink(val link: String, val api: ConfluenceApi, val pageId: String, val result : FetchResult)  : Source {

    override fun description() = result.get("body") as String
    override fun title() = result.get("title") as String
    companion object {
        suspend fun create(link: String, api: ConfluenceApi): ConfluenceLink {
            val pageId = getPageId(link, api)
            val result = getResult(pageId, api)
            return ConfluenceLink(link, api, pageId, result)
        }
        private suspend fun getPageId(link: String, api: ConfluenceApi): String = api.fetchPageId(link) ?: throw IllegalArgumentException("no page id")

        private suspend fun getResult(pageId : String, api : ConfluenceApi) = api.fetch(pageId, FetchOption("title", "$.title"), FetchOption("body", "$.body.view.value", true))
    }
}


=====================================================================
Document 47: File name FetchResult.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.confluence, FetchResult

- Description
package com.ingenifi.unifile.formatter.confluence

class FetchResult(private val resultMap: Map<String, Any>) {

    fun get(key: String): Any? = resultMap[key]

    fun get(): Any? = resultMap["payload"]

    fun getTokens(key: String): List<String>? {
        return when (val value = get(key)) {
            is String -> tokenize(value)
            is List<*> -> value.filterIsInstance<String>().flatMap { tokenize(it) }
            else -> null
        }
    }

    private fun tokenize(str: String): List<String> {
        return str.split("\\s+".toRegex())
    }
}


=====================================================================
Document 48: File name ConfluencePagesFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter.confluence, ConfluencePagesFormatter

- Description
package com.ingenifi.unifile.formatter.confluence

import com.ingenifi.unifile.VerbosePrinter
import com.ingenifi.unifile.VerbosePrinting
import com.ingenifi.unifile.Verbosity
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import io.ktor.client.*
import kotlinx.coroutines.runBlocking
import java.io.File

data class ConfluencePagesFormatter(private val properties: Map<String, String>, private val client: HttpClient, private val file: File, private val keywordExtractor: KeywordExtractor, private val verbosity: Verbosity) : DocumentFormatter,
    VerbosePrinting by VerbosePrinter(verbosity) {
    private val username = properties["username"] ?: throw IllegalArgumentException("User name not specified in properties")
    private val password = properties["password"] ?: throw IllegalArgumentException("Password not specified in properties")
    private val api = ConfluenceApi(client, username, password)
    private var lastNumber = 0

    override fun format(number: Int): String = runBlocking { formatSuspended(number) }
    private suspend fun formatSuspended(number: Int): String {
        lastNumber = number
        return file.readLines().map { ConfluenceLink.create(it, api) }
            .joinToString("\n") { link ->
                verbosePrint("Processing link: ${link.link}")
                ConfluencePageFormatter(link, keywordExtractor).format(lastNumber++)
            }
    }
    override fun lastNumber(): Int = lastNumber
}


=====================================================================
Document 49: File name WordSource.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.word, WordSource

- Description
package com.ingenifi.unifile.formatter.word

import com.ingenifi.unifile.formatter.Source
import java.io.File

data class WordSource(val file: File) : Source {
    override fun description(): String = file.toText()
    override fun title(): String = file.name
    private fun File.toText(): String = WordConverter().convert(this)

}


=====================================================================
Document 50: File name WordFormatter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.word, WordFormatter

- Description
package com.ingenifi.unifile.formatter.word

import com.ingenifi.unifile.formatter.Delegate
import com.ingenifi.unifile.formatter.DocumentFormatter
import com.ingenifi.unifile.formatter.KeywordExtractor
import java.io.File

data class WordFormatter(val file: File, private val keywordExtractor: KeywordExtractor) : DocumentFormatter {
    private val delegate = Delegate(WordSource(file), keywordExtractor)
    override fun format(number: Int): String = delegate.format(number, templatePath = "word-document.tmpl", replacements = mapOf<String, String>("filename" to file.name))
    override fun lastNumber(): Int = delegate.lastNumber()
}




=====================================================================
Document 51: File name WordConverter.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: kotlin, com.ingenifi.unifile.formatter.word, WordConverter

- Description
package com.ingenifi.unifile.formatter.word

import org.apache.poi.hwpf.HWPFDocument
import org.apache.poi.hwpf.extractor.WordExtractor
import org.apache.poi.xwpf.usermodel.XWPFDocument
import java.io.File
import java.io.FileInputStream

class WordConverter {

    fun convert(wordFile: File): String {
        return if (wordFile.extension == "doc") {
            convertDoc(wordFile)
        } else {
            convertDocx(wordFile)
        }
    }

    private fun convertDoc(file: File): String {
        FileInputStream(file).use { fis ->
            val document = HWPFDocument(fis)
            val extractor = WordExtractor(document)
            val text = extractor.text
            extractor.close()
            return text
        }
    }

    private fun convertDocx(file: File): String {
        FileInputStream(file).use { fis ->
            val document = XWPFDocument(fis)
            return document.paragraphs.joinToString("\n") { it.text }
        }
    }
}



=====================================================================
Document 52: File name KeywordExtractor.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter, KeywordExtractor

- Description
package com.ingenifi.unifile.formatter

import java.nio.charset.StandardCharsets

data class KeywordExtractor(val percentage: Double = 0.025, val stopWords: List<String> = gatherStopWords(), val filters: List<(String) -> Boolean> = listOf()
) {

    fun extract(text: String, percentage: Double = this.percentage): List<String> {

        val words = text.split("\\s+".toRegex()).map { it.lowercase().trim() }.map { it.replace(Regex("[^\\w\\s]"), "") }
        val filteredWords = words.filterNot { it in stopWords }.filter { word -> filters.all{ filter -> filter(word)} }

        val frequencyMap = filteredWords.groupingBy { it }.eachCount()
        val sortedByFrequency = frequencyMap.entries.sortedByDescending { it.value }

        val numberOfKeywords = (sortedByFrequency.size * percentage).toInt()
        return sortedByFrequency.take(numberOfKeywords).map { it.key }
    }

    companion object {
        private fun gatherStopWords(): List<String> {
            val resourceAsStream = this::class.java.getResourceAsStream("/all-stop-words.txt")
            if (resourceAsStream != null) {
                return resourceAsStream.bufferedReader(StandardCharsets.UTF_8).readLines()
            } else {
                throw IllegalArgumentException("Resource not found: /all-stop-words.txt")
            }
        }
    }


}




=====================================================================
Document 53: File name Delegate.kt
=====================================================================
- Introduction:
This is a kotlin class
keywords are: , kotlin, com.ingenifi.unifile.formatter, Delegate

- Description
package com.ingenifi.unifile.formatter

class Delegate(private val source: Source, private val keywordExtractor: KeywordExtractor) {
    private var lastNumber = 0

    companion object {
        private val templateCache = mutableMapOf<String, String>()

        private fun loadTemplate(templatePath: String): String {
            return templateCache.getOrPut(templatePath) {
                Delegate::class.java.classLoader.getResource(templatePath)?.readText()
                    ?: throw IllegalArgumentException("Template resource could not be read: $templatePath")
            }
        }
    }

    fun format(number: Int, templatePath: String, replacements: Map<String, String> = mapOf(), extractPercentage: Double = 0.025, additionalKeywords : List<String> = listOf<String>()): String {
        val description = source.description()
        val title = source.title()
        val keywords = mutableSetOf<String>()
        keywords.addAll(keywordExtractor.extract(text = description, percentage = extractPercentage))
        if (additionalKeywords.isNotEmpty()) keywords.addAll(additionalKeywords)

        var template = loadTemplate(templatePath)

        template = template.replace("{number}", number.toString())
            .replace("{title}", title)
            .replace("{description}", description)
            .replace(", kotlin, com.ingenifi.unifile.formatter, Delegate", keywords.joinToString(", "))
        replacements.forEach { (key, value) -> template = template.replace("{$key}", value) }

        lastNumber = number + 1
        return template
    }

    fun lastNumber(): Int = lastNumber
}

